---
layout: post
title: '谈谈后端业务系统的微服务化改造 文章摘要'
date: 2016-11-28
author: Pengfei.X
version: 0.1
categories: [reading,]
---

[谈谈后端业务系统的微服务化改造](http://www.infoq.com/cn/articles/the-back-end-business-systems-service-transformation)
[从单体架构迁移到微服务，8个关键的思考、实践和经验](http://www.infoq.com/cn/news/2016/08/Monomer-architecture-Micro-servi)

## 问题

业务系统是任何一个用户产品的必须组成，充当着一个门面的角色，用户的输入就是这个系统需要维护的，数据
存取是整个系统的核心。例如，广告业务系统的输入是广告主的投放约束、定向条件，微博业务系统的输入是短
文字、图片等。

在应用发展初期或者规模不大的情况下，有非常简单的实现方案，LNMP、JSP、PyWeb都是你能随口说出来的词，
如果用某种架构方式来描述，那就可以称做单体模式（Monolithic，Martin Flower大神所提出的，后面还会介绍），
而这些技术都是单体模式的成熟解决方案，它们可以使你工作在“应用层”的最顶端，各种中间件、框架能让你
省心地干好业务，开发人员可以通过“模块化”的手段来管理业务系统的复杂度，使他们之间解耦、复用。
简单来说，这个单体就是如下这种层次划分。

    表示层       前端（HTML+CSS+JS）                        
      |             |
    逻辑层     业务系统（PHP、Java、Python是常用的语言）         
      |             |                               
    数据层      数据库（MySQL）    


看起来很简单，对吧。诚然，业务系统在这里面还需要做很多，比如缓存、SQL优化、数据分区、系统安全工作，
当然还有对于代码的维护和重构。这种工作方式可以很好的工作几年、甚至十年，但是如果业务发展非常快，在
系统复杂度、业务规模、参与人数、代码腐化程度都不断上升的情况下，你会发现整个项目正陷于泥潭，PM/RD/QA/OP经常抱怨：

    "改个小功能，怎么要拉这么多模块？"

    "拉模块也就罢了，改的地方多，编译太慢了。"

    "慢也就算了，关键不知道怎么改，这代码太丑陋了，算了，为了满足PM的排期需要，凑合来吧。"

    "凑合来了，QA发现bug，返工再返工，延期再延期。"

    "上线了，oh my god，报case了，性能有问题，原来是依赖的模块访问数据库用了for循环select。"


透过现象看本质，我总结了来看就这三点问题：

1、业务逻辑复杂耦合，开发维护成本高。
2、交付效率和质量低。
3、非功能需求不达标。

非功能需求指标特指性能、可用性、可扩展性等方面，代码的腐化和缺少维护、重构，以及没有代码洁癖的人
污染下，必然导致性能逐渐下降，甚至出现不同资源竞争的短板效应，造成整个系统crash，同时一个大怪物
的伸缩性较差，不能随意横向扩展某个细分功能点。

`Design is there to enable you to keep changing the software easily in the long term!`

业务系统中模块化实践，随着软件规模的变大，很容易绕过障碍而使得不同模块耦合、依赖关系复杂，这种纪律
性很难保证，从而削弱模块化的结构、降低了团队的生产力（敏捷开发和持续交付越来越难做，部署起来太庞大
了大家的开发士气不高，而且痛苦），很快的这个模块就会变成一个大杂烩。

## 服务化

服务是独立开发，独立测试，独立发布，独立部署，独立运维的，某个细分团队负责整个生命周期管理，这就
是”康威定律（Conway’s law）”的通俗解释，官方解释是“一个组织的设计成果，其结构往往对应于这个组
织中的沟通结构”，服务的规划不就是多人、跨团队协作的沟通模式嘛。好处在于摒弃原来的火车模型（所有模
块一起发布部署），拥抱独立快跑，这也更好的支持了敏捷和持续集成的方法实践。同时去除了牵一发而动全
身的问题，单一职责的来进行修改需求或者重构一个点，开发和构建方便，不影响整个产品的功能，一个bug
不会crash掉整个产品，针对不同的类型，区分计算密集型还是I/O密集型，区分业务上更好使用关系型还是
NoSQL，`区分2/8原则、即80%经常修改的服务独立出来自成一家`，区分短板功能、针对瓶颈可以做水平扩展、
避免资源竞争，甚至可以区分技术栈、突破语言限制。

## 2016-12-20 重新摘抄

“Design is there to enable you to keep changing the software easily in the long term” ，即“变化发生时设计被破坏的程度”

微服务中的组件在逻辑或者物理层次更趋于细分，这个细分不是极致的，而是一种粒度适中的选择，通常这些组件在前期可以是一些模块，但是当需要时，例如业务上需要拆分独立，或者非功能需求上需要扩容等，都可以灵活的拆解出来。

这个特点非常重要，因为业务系统中模块化实践，随着软件规模的变大，很容易绕过障碍而使得不同模块耦合、依赖关系复杂，这种纪律性很难保证，从而削弱模块化的结构、降低了团队的生产力（敏捷开发和持续交付越来越难做，部署起来太庞大了大家的开发士气不高，而且痛苦），很快的这个模块就会变成一个大杂烩，而服务可以做到天然的壁垒，仅仅通过交换契约（通常是API或者proto）来做交互，这是一个演化的过程，不仅有利于分而治之，到达复用的目的，同时老系统也可以灰度的改造剥离。

这意味着服务是独立开发，独立测试，独立发布，独立部署，独立运维的，某个细分团队负责整个生命周期管理，这就是”康威定律（Conway’s law）”的通俗解释，官方解释是“一个组织的设计成果，其结构往往对应于这个组织中的沟通结构”，服务的规划不就是多人、跨团队协作的沟通模式嘛

去除了牵一发而动全身的问题，单一职责的来进行修改需求或者重构一个点，开发和构建方便，不影响整个产品的功能，一个bug不会crash掉整个产品，针对不同的类型，区分计算密集型还是I/O密集型，区分业务上更好使用关系型还是NoSQL，区分2/8原则、即80%经常修改的服务独立出来自成一家，区分短板功能、针对瓶颈可以做水平扩展、避免资源竞争，甚至可以区分技术栈、突破语言限制。最后，这也是和第一点遥相呼应的，独立的服务可以实现非常大程度上的复用，服务之间依赖轻量级的接口，而不是模块。

《Exploring the Duality Between Product and Organizational Architectures》书中给了一个很有意思的观点，组织的耦合度与系统的模块化成正比。即组织耦合度越高，所开发的产品耦合度越高；组织耦合度越低，所开发的产品耦合度也越低。微服务架构本质上在强调松耦合的架构，因此在微服务架构迁移前，我们有必要对组织进行微调（不要变革，对组织影响很大），确保独立的、小的团队交付一个微服务，同时小团队是微服务的Owner（除了负责开发外，同时负责测试和运维）。这会极大提供团队的责任感，加速微服务的自治和交付能力。

数据模型能否彻底分开，决定了微服务的边界功能是否彻底划清。我们已经见过太多直接从服务分离而造成多次重构和返工的案例。针对业务系统，重新梳理概念模型+数据模型，切分出松耦合、高内聚的微服务，保障项目组在做正确的事情。
