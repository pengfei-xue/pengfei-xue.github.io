---
layout: post
title: 'ci一点想法'
date: 2016-03-27
author: Pengfei.X
version: 0.1
categories: [ops, ]
---

## 构建基础

针对不同的环境，需要有不同的配置，这些配置也需要被放入版本管理中，代码仓库必须
包含所有构建依赖到的内容。

	qa.properties
	local.properties
	prodution.properties

构建需要按照不同的场景来划分，包括本地构建，集成构建以及发布构建，针对我们目前的
情况来说，可以先做集成构建，保证版本兼容。同时，需要有工具，可以让开发很方便地在
本地做构建，让开发有方法去验证自己的代码在做构建时，不会出现问题，以至于团队的其
它成员没法，基于最新的代码做构建，never break the CI。

为了保持环境的一致性，以及可重用，节省费用，可以考虑使用docker container来做集成
测试的环境，*制作基础镜像*，构建时，基于这个镜像来运行构建环境，对环境的更改不会
影响到基础镜像，用完即抛。


## 版本分支管理
构建必须是针对主干，我们目前遇到的问题是测试的分支不是最终上线的分支，我们的分支
大致是这样的：

    master o -> o -> o -> o - - - - - - - - - - - - - - - - - - - -> o
                           \                                      /
    test                    o -> o -> o -> o -> o -> o - - - -> o          
                                            \              /
    dev                                      o -> o -> o  /

我们开发版本在dev分支进行，开发结束后合并进test分支，给qa做测试，期间的左右bugfix的
代码都会进入到test分支。同时，在dev分支，我们会进行下个版本的开发，期间还可能会有一些
临时的需求，需要根据master切出分支做。但是，我们目前的测试的分支，都不是最终上线的分支，也就是说，我们测试的是test分支，或者一个hotfix分支，可最终上线的分支确是master分支，当然，你可以说，只要最终的两个分支代码是一致的，就不会有问题。不过，谁能保证我们在merge过程中，不会出现失误呢，之前遇到过这样的情况，由于merge的时候，git自动处理的结果
有一些问题，导致出现bug，这些都是要避免掉的。所以，我的建议还是根据feature来开发，开发结束后，merge进master分支，或者有特殊的发布分支，确保，测试测的分支，就是我们最终上线的分支。


## 数据库持续集成
最早，我们使用Django自带的数据库管理工具，来管理数据库的变更，但是，作为创业公司，不断有临时需求加入到开发中来，所以导致每次做数据库变更的代价都非常高，特别是有分支合并的时候，经常出现分支合并结束后，自动化的数据库变更管理脚本就跑不了了。另外，每次上线之前，我们都需要dump一份最新的数据库到本地，然后基于这个数据库，来生成变更脚本，成本非常高，没有效率。

之后我们，放弃了Django自带的工具，而是直接写了raw sql，我们定义了一套变更的规范，基于这个规范来写变更脚本，没有做自动化，但确实是减少了上线成本。最后，调研了Sqitch，可以支持，变更管理，自带了一套应用变更，回滚变更，验证变更的机制。另外，之前尝试了相关项目的自动化测试，用Sqitch，对数据库做变更自动化管理也非常方便。
